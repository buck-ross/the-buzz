import React from 'react';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Card from '@mui/material/Card';
import styles from '@/styles/usersList.module.css';
import Loader from '@/components/Loader';
import Navbar from '@/components/Navbar';
import UserEdit from '@/components/UserEdit';

/**
* This class defines how the application's homepage will be displayed.
* It includes the navbar (imported from @/components/Navbar) and either a list of users or a form to add a new user
*/
export default class UsersList extends React.Component {
	/**
	* The constructor runs once every time a new instance of the component is created.
	* It can be used to set the initial state of the application.
	*/
	constructor(props) {
		super(props); // Inform the parent class of the properties passed in

		// Set the initial state of the list of users:
		this.state = {
			addUser: false,
			loading: true,
			users: []
		};
	}

	/**
	* `componentDidMount` is a special method which runs every time a component is displayed on the screen.
	* Note that it is safe to assume that the constructor will be called before the component is mounted.
	*/
	componentDidMount() {
		// Refresh the list of users:
		this.refresh();
	}

	/**
	* The refresh function will update the content of the "users" list by sending an HTTP GET request
	* to the appropriate API endpoint.
	*/
	async refresh() {
		// Update the component state to indicate that the request is loading:
		this.setState({ loading: true, users: [] });

		try {
			// Send a GET request to the '/api/users' endpoint to fetch a list of users:
			const result = await fetch('/api/users')
				.then(res => res.ok ? res : Promise.reject(res)) // Treat HTTP error codes as errors
				.then(res => res.json()); // Extract the JSON data fom the response

			// For each user returned from the server, create a list-element to be displayed in the users list:
			let userList = [];
			for(let user of result) {
				userList.push(
					<Card
						className={styles.userCard}
						key={user.email}
						data-email={user.email}
						onClick={this.clickUser.bind(this)}
					>
						{user.name} &lt;{user.email}&gt;
					</Card>
				);
			}

			// Update the state to reflect the new set of users:
			this.setState({ loading: false, users: userList });
		} catch (err) {
			// Handle any errors generated by the above query:
			this.setState({ loading: false });
			await this.handleNetworkError(err);
		}
	}

	/**
	* When the "Submit" button is clicked on the add-user form, this function is invoked to actually add the user
	* by sending an HTTP POST request to the appropriate API route.
	* You'll notice that it's structure is very similar to "refresh", only it's focus is more on the data being uploaded
	* rather than the data being downloaded.
	*/
	async addUserSubmit(user) {
		// Update the component state to indicate that the request is loading:
		this.setState({ loading: true });

		try {
			// Send a POST request to the '/api/users' endpoint to upload the new user's data:
			await fetch('/api/users', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(user)
			}).then(res => res.ok ? res : Promise.reject(res)); // Treat HTTP error codes as errors

			// Once the request has completed, refresh the main users list:
			this.setState({ addUser: false });
			await this.refresh();
		} catch (err) {
			// Handle any errors generated by the above HTTP request:
			this.setState({ loading: false });
			await this.handleNetworkError(err);
		}
	}

	/**
	* Toggle between displaying the list of users or displaying the form to add a new user
	*/
	addUserToggle() {
		this.setState({ addUser: !this.state.addUser });
	}

	/**
	* When a user's entry is clicked in the list, this method is called in order to navigate
	* to that user's profile page.
	* @param {MouseEvent} evt the event data with information about the clicked user
	*/
	clickUser(evt) {
		const email = evt.target.dataset.email;
		this.props.history.push('/users/' + encodeURIComponent(email));
	}

	/**
	* Handle any networking-related errors which may arise when interacting with the '/api/users` endpoint
	* IMPORTANT: `alert` and `console.error` aren't great for error handling. Consider replacing this
	*     with some sort of modal.
	* @param {Response|Error} error The error thrown by `fetch`
	* @returns {Promise} resolves once the error has been handled
	*/
	async handleNetworkError(error) {
		console.error(error);
		if (typeof error.text === 'function') {
			alert(`Error ${error.status}: ${await error.text()}`);
		} else {
			alert(`Network error: ${error}`);
		}
		this.props.history.push('/');
	}

	/**
	* The "render" function is a special React function that returns a JSX component which will be
	* shown on the page in place of the current class.
	*/
	render() {
		let content;
		if(this.state.addUser) {
			// If the "addUser" flag is true, the page's content should be a form which can be used to create a new user:
			content = <UserEdit
				cancel={this.addUserToggle.bind(this)}
				submit={this.addUserSubmit.bind(this)}
			/>;
		} else {
			// If the "addUser" flag is false, display a list of all of the users in the system:
			content = <div className={styles.list}>
				<Box id='usersList' className={styles.list}>
					{this.state.users}
				</Box>
				<Box className={styles.footer}>
					<Button
						onClick={this.addUserToggle.bind(this)}
						variant='contained'
						sx={{backgroundColor: 'yellow', color: 'black'}}
					>
						Add User
					</Button>
				</Box>
			</div>;
		}

		// Return the actual page structure:
		return <div>
			<Navbar/>
			{content}
			<Loader loading={this.state.loading}/>
		</div>;
	}
}
