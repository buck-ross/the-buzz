import React from 'react';
import Button from '@mui/material/Button';
import styles from '@/styles/userProfile.module.css';
import Loader from '@/components/Loader';
import Navbar from '@/components/Navbar';
import UserEdit from '@/components/UserEdit';

export default class UserProfile extends React.Component {
	/**
	* The constructor runs once every time a new instance of the component is created.
	* It can be used to set the initial state of the application.
	*/
	constructor(props) {
		super(props); // Inform the parent class of the properties

		// Set the initial state of the profile page:
		const email = decodeURIComponent(this.props.match.params.email);
		this.state = {
			user: {
				email: email,
				name: '',
				bio: ''
			},
			editing: false,
			loading: true
		};
	}

	/**
	* The "componentDidMount" method is a special method which runs every time a component
	* is displayed on the screen. Note that it is safe to assume that the constructor will be
	* called before the component is mounted.
	*/
	componentDidMount() {
		// Refresh the profile data:
		this.refresh();
	}

	/**
	* The refresh function will update the content of the profile page
	* by sending an HTTP GET request to the appropriate API endpoint.
	*/
	async refresh() {
		// Update the component state to indicate that the request is loading:
		this.setState({ loading: true });

		try {
			// Send a GET request to the '/api/users/:email' endpoint to fetch the profile data:
			const user = await fetch('/api/users/' + encodeURIComponent(this.state.user.email))
				.then(res => res.ok? res : Promise.reject(res)) // Treat HTTP error codes as errors
				.then(res => res.json());

			// Update the component's state to reflect the fetched profile data:
			this.setState({
				user: user,
				loading: false
			});
		} catch (err) {
			// Handle any errors generated by the above query:
			this.setState({ loading: false });
			await this.handleNetworkError(err);
		}
	}

	/**
	* When the "Submit" button is clicked on the edit form, this function is invoked to actually update the user
	* by sending an HTTP PUT request to the appropriate API route.
	* You'll notice that it's structure is very similar to "refresh", only it's focus is more on the data being uploaded
	* rather than the data being downloaded.
	*/
	async editSubmit(user) {
		// Update the component state to indicate that the request is loading:
		this.setState({ loading: true });

		try {
			// Send a PUT request to the '/api/users/:email' endpoint to update the profile data:
			await fetch('/api/users/' + encodeURIComponent(this.state.user.email), {
				method: 'PUT',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(user)
			}).then(res => res.ok? res : Promise.reject(res)); // Treat HTTP error codes as errors


			// Once the user has been uploaded, refresh the main users list:
			this.setState({ editing: false, user: user });
			await this.refresh();
		} catch (err) {
			// Handle any errors generated by the above query:
			this.setState({ loading: false });
			await this.handleNetworkError(err);
		}
	}

	/**
	* When the "Delete User" button is clicked, this function is called to send the HTTP DELETE request
	* to the API server which will remove the user from the database.
	* You'll notice that it's structure is very similar to "refresh", only it doesn't need to do anything
	* with the result.
	*/
	async deleteUser() {
		// Update the component state to indicate that the request is loading:
		this.setState({ loading: true });

		try {
			// Send a PUT request to the '/api/users/:email' endpoint to update the profile data:
			await fetch('/api/users/' + encodeURIComponent(this.state.user.email), {
				method: 'DELETE'
			}).then(res => res.ok? res : Promise.reject(res)); // Treat HTTP error codes as errors

			// Go to the last page the user had previously accessed before the current page
			this.props.history.go(-1);
		} catch (err) {
			// Handle any errors generated by the above query:
			this.setState({ loading: false });
			await this.handleNetworkError(err);
		}
	}

	/**
	* Toggle between displaying the profile information and the editing form
	*/
	editToggle() {
		this.setState({ editing: !this.state.editing });
	}

	/**
	* Handle any networking-related errors which may arise when interacting with the '/api/users` endpoint
	* IMPORTANT: `alert` and `console.error` aren't great for error handling. Consider replacing this
	*     with some sort of modal.
	* @param {Response|Error} error The error thrown by `fetch`
	* @returns {Promise} resolves once the error has been handled
	*/
	async handleNetworkError(error) {
		console.error(error);
		if (typeof error.text === 'function') {
			alert(`Error ${error.status}: ${await error.text()}`);
		} else {
			alert(`Network error: ${error}`);
		}
		this.props.history.push('/');
	}

	render() {
		let content;
		if(this.state.editing) {
			content = <UserEdit
				cancel={this.editToggle.bind(this)}
				submit={this.editSubmit.bind(this)}
				user={this.state.user}
			/>;
		} else {
			content = <div className={styles.profile}>
				<h2>{this.state.user.name}</h2>
				<h3>Email: <a href={'mailto:' + this.state.user.email}>{this.state.user.email}</a></h3>
				<p>{this.state.user.bio}</p>
				<Button
					id='editButton'
					className={styles.editButton}
					variant='contained'
					onClick={this.editToggle.bind(this)}
				>
					Edit User
				</Button>
				{/* Show a button to delete the current user: */}
				<Button
					id='deleteButton'
					className={styles.deleteButton}
					variant='contained'
					onClick={this.deleteUser.bind(this)}
				>
					Delete User
				</Button>
			</div>;
		}

		return (
			<div>
				<Navbar/>
				{content}
				<Loader loading={this.state.loading}/>
			</div>
		);
	}
}
